{"version":3,"sources":["rack/persistence/adapters/indexeddb.js"],"names":[],"mappings":"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","file":"rack/persistence/adapters/indexeddb.js","sourcesContent":["import Promise from 'babybird';\nimport { KinveyError, NotFoundError } from '../../../errors';\nimport forEach from 'lodash/forEach';\nimport isArray from 'lodash/isArray';\nimport isString from 'lodash/isString';\nimport isFunction from 'lodash/isFunction';\nconst dbCache = {};\n\nconst TransactionMode = {\n  ReadWrite: 'readwrite',\n  ReadOnly: 'readonly',\n};\nObject.freeze(TransactionMode);\n\nif (typeof window !== 'undefined') {\n  require('indexeddbshim');\n  global.shimIndexedDB.__useShim();\n}\n\nconst indexedDB = global.shimIndexedDB ||\n                  global.indexedDB ||\n                  global.mozIndexedDB ||\n                  global.webkitIndexedDB ||\n                  global.msIndexedDB;\n\n/**\n * @private\n */\nexport class IndexedDB {\n  constructor(name) {\n    if (!name) {\n      throw new KinveyError('A name for the collection is required to use the memory persistence adapter.', name);\n    }\n\n    if (!isString(name)) {\n      throw new KinveyError('The name of the collection must be a string to use the memory persistence adapter', name);\n    }\n\n    this.name = name;\n    this.inTransaction = false;\n    this.queue = [];\n  }\n\n  openTransaction(collection, write = false, success, error, force = false) {\n    let db = dbCache[this.name];\n\n    if (db) {\n      const containsCollection = isFunction(db.objectStoreNames.contains) ?\n        db.objectStoreNames.contains(collection) : db.objectStoreNames.indexOf(collection) !== -1;\n\n      if (containsCollection) {\n        try {\n          const mode = write ? TransactionMode.ReadWrite : TransactionMode.ReadOnly;\n          const txn = db.transaction([collection], mode);\n\n          if (txn) {\n            const store = txn.objectStore(collection);\n            return success(store);\n          }\n\n          throw new KinveyError(`Unable to open a transaction for the ${collection} ` +\n            `collection on the ${this.name} indexedDB database.`);\n        } catch (err) {\n          return error(err);\n        }\n      } else if (!write) {\n        return error(new NotFoundError(`The ${collection} collection was not found on ` +\n          `the ${this.name} indexedDB database.`));\n      }\n    }\n\n    if (!force && this.inTransaction) {\n      return this.queue.push(() => {\n        this.openTransaction(collection, write, success, error);\n      });\n    }\n\n    // Switch flag\n    this.inTransaction = true;\n    let request;\n\n    if (db) {\n      const version = db.version + 1;\n      request = indexedDB.open(this.name, version);\n    } else {\n      request = indexedDB.open(this.name);\n    }\n\n    // If the database is opened with an higher version than its current, the\n    // `upgradeneeded` event is fired. Save the handle to the database, and\n    // create the collection.\n    request.onupgradeneeded = e => {\n      db = e.target.result;\n\n      if (write) {\n        db.createObjectStore(collection, { keyPath: '_id' });\n      }\n    };\n\n    // The `success` event is fired after `upgradeneeded` terminates.\n    // Save the handle to the database.\n    request.onsuccess = e => {\n      db = e.target.result;\n      dbCache[this.name] = db;\n\n      // If a second instance of the same IndexedDB database performs an\n      // upgrade operation, the `versionchange` event is fired. Then, close the\n      // database to allow the external upgrade to proceed.\n      db.onversionchange = () => {\n        if (db) {\n          db.close();\n          db = null;\n          dbCache[this.name] = null;\n        }\n      };\n\n      // Try to obtain the collection handle by recursing. Append the handlers\n      // to empty the queue upon success and failure. Set the `force` flag so\n      // all but the current transaction remain queued.\n      const wrap = done => {\n        const callbackFn = arg => {\n          done(arg);\n\n          // Switch flag\n          this.inTransaction = false;\n\n          // The database handle has been established, we can now safely empty\n          // the queue. The queue must be emptied before invoking the concurrent\n          // operations to avoid infinite recursion.\n          if (this.queue.length > 0) {\n            const pending = this.queue;\n            this.queue = [];\n            forEach(pending, fn => {\n              fn.call(this);\n            });\n          }\n        };\n        return callbackFn;\n      };\n\n      return this.openTransaction(collection, write, wrap(success), wrap(error), true);\n    };\n\n    request.onblocked = () => {\n      error(new KinveyError(`The ${this.name} indexedDB database version can't be upgraded ` +\n        'because the database is already open.'));\n    };\n\n    request.onerror = e => {\n      error(new KinveyError(`Unable to open the ${this.name} indexedDB database. ` +\n        `Received the error code ${e.target.errorCode}.`));\n    };\n\n    return null;\n  }\n\n  find(collection) {\n    const promise = new Promise((resolve, reject) => {\n      if (!collection) {\n        return reject(new KinveyError('A collection was not provided.'));\n      }\n\n      return this.openTransaction(collection, false, store => {\n        const request = store.openCursor();\n        const response = [];\n\n        request.onsuccess = e => {\n          const cursor = e.target.result;\n\n          if (cursor) {\n            response.push(cursor.value);\n            return cursor.continue();\n          }\n\n          return resolve(response);\n        };\n\n        request.onerror = e => {\n          reject(new KinveyError(`An error occurred while fetching data from the ${collection} ` +\n            `collection on the ${this.name} indexedDB database. Received the error code ${e.target.errorCode}.`));\n        };\n      }, error => {\n        if (error instanceof NotFoundError) {\n          return resolve([]);\n        }\n\n        return reject(error);\n      });\n    });\n\n    return promise;\n  }\n\n  findById(collection, id) {\n    const promise = new Promise((resolve, reject) => {\n      this.openTransaction(collection, false, store => {\n        const request = store.get(id);\n\n        request.onsuccess = e => {\n          const entity = e.target.result;\n\n          if (entity) {\n            return resolve(entity);\n          }\n\n          return reject(new NotFoundError(`An entity with _id = ${id} was not found in the ${collection} ` +\n            `collection on the ${this.name} indexedDB database.`));\n        };\n\n        request.onerror = (e) => {\n          reject(new KinveyError(`An error occurred while retrieving an entity with _id = ${id} ` +\n            `from the ${collection} collection on the ${this.name} indexedDB database. ` +\n            `Received the error code ${e.target.errorCode}.`));\n        };\n      }, error => {\n        if (error instanceof NotFoundError) {\n          return reject(new NotFoundError(`An entity with _id = ${id} was not found in the ${collection} ` +\n            `collection on the ${this.name} indexedDB database.`));\n        }\n\n        return reject(error);\n      });\n    });\n\n    return promise;\n  }\n\n  save(collection, entities) {\n    let singular = false;\n\n    if (!isArray(entities)) {\n      entities = [entities];\n      singular = true;\n    }\n\n    if (entities.length === 0) {\n      return Promise.resolve(entities);\n    }\n\n    const promise = new Promise((resolve, reject) => {\n      this.openTransaction(collection, true, store => {\n        const request = store.transaction;\n\n        forEach(entities, entity => {\n          store.put(entity);\n        });\n\n        request.oncomplete = function onComplete() {\n          resolve(singular ? entities[0] : entities);\n        };\n\n        request.onerror = (e) => {\n          reject(new KinveyError(`An error occurred while saving the entities to the ${collection} ` +\n            `collection on the ${this.name} indexedDB database. Received the error code ${e.target.errorCode}.`));\n        };\n      }, reject);\n    });\n\n    return promise;\n  }\n\n  removeById(collection, id) {\n    const promise = new Promise((resolve, reject) => {\n      this.openTransaction(collection, true, store => {\n        const request = store.transaction;\n        const doc = store.get(id);\n        store.delete(id);\n\n        request.oncomplete = () => {\n          if (!doc.result) {\n            return reject(new NotFoundError(`An entity with id = ${id} was not found in the ${collection} `\n              + `collection on the ${this.name} indexedDB database.`));\n          }\n\n          return resolve({\n            count: 1,\n            entities: [doc.result]\n          });\n        };\n\n        request.onerror = e => {\n          reject(new KinveyError(`An error occurred while deleting an entity with id = ${id} ` +\n            `in the ${collection} collection on the ${this.name} indexedDB database. ` +\n            `Received the error code ${e.target.errorCode}.`));\n        };\n      }, reject);\n    });\n\n    return promise;\n  }\n\n  static isSupported() {\n    return indexedDB !== undefined;\n  }\n}\n"],"sourceRoot":"/source/"}