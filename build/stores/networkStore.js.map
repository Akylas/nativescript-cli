{"version":3,"sources":["stores/networkStore.js"],"names":[],"mappings":";;;;;;;;;AAAA;;;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;AACA,IAAM,mBAAmB,QAAQ,GAAR,CAAY,0BAAZ,IAA0C,SAA1C;AACzB,IAAM,cAAc,QAAQ,GAAR,CAAY,mBAAZ,IAAmC,KAAnC;;;;;;;IAMP;;;;;;;;;AAQX,WARW,YAQX,CAAY,IAAZ,EAAkB;0BARP,cAQO;;AAChB,QAAI,QAAQ,CAAC,wBAAS,IAAT,CAAD,EAAiB;AAC3B,YAAM,wBAAgB,wBAAhB,CAAN,CAD2B;KAA7B;;;;;AADgB,QAQhB,CAAK,IAAL,GAAY,IAAZ;;;;;;AARgB,QAchB,CAAK,MAAL,GAAc,eAAO,cAAP,EAAd,CAdgB;GAAlB;;;;;;;;;eARW;;;;;;;;;;;;;;;;;;;yBAuDN,OAAqB;;;UAAd,gEAAU,kBAAI;;AACxB,eAAI,KAAJ,qCAA4C,KAAK,IAAL,iBAA5C,EAAqE,KAArE,EADwB;;AAGxB,gBAAU,sBAAO;AACf,oBAAY,IAAZ;AACA,iBAAS,SAAT;AACA,oCAAU,EAHK;OAAP,EAIP,OAJO,CAAV,CAHwB;AAQxB,cAAQ,KAAR,GAAgB,aAAG,KAAH,CAAS,QAAQ,KAAR,CAAzB,CARwB;;AAUxB,UAAI,SAAS,EAAE,8BAAF,EAA2B;AACtC,eAAO,mBAAQ,MAAR,CAAe,wBAAgB,kEAAhB,CAAf,CAAP,CADsC;OAAxC;;AAIA,UAAM,UAAU,4BAAmB;AACjC,gBAAQ,kBAAW,GAAX;AACR,kBAAU,gBAAS,OAAT;AACV,aAAK,cAAI,MAAJ,CAAW;AACd,oBAAU,KAAK,MAAL,CAAY,QAAZ;AACV,gBAAM,KAAK,MAAL,CAAY,IAAZ;AACN,oBAAU,KAAK,SAAL;SAHP,CAAL;AAKA,oBAAY,QAAQ,UAAR;AACZ,eAAO,KAAP;AACA,iBAAS,QAAQ,OAAR;AACT,gBAAQ,KAAK,MAAL;OAXM,CAAV,CAdkB;;AA4BxB,UAAM,UAAU,QAAQ,OAAR,GAAkB,IAAlB,CAAuB;eAAY,SAAS,IAAT;OAAZ,CAAjC,CA5BkB;;AA8BxB,cAAQ,IAAR,CAAa,oBAAY;AACvB,iBAAI,IAAJ,oCAA0C,MAAK,IAAL,iBAA1C,EAAmE,QAAnE,EADuB;OAAZ,CAAb,CAEG,KAFH,CAES,iBAAS;AAChB,iBAAI,KAAJ,6CAAoD,MAAK,IAAL,iBAApD,EAA6E,KAA7E,EADgB;OAAT,CAFT,CA9BwB;;AAoCxB,aAAO,OAAP,CApCwB;;;;;;;;;;;;;;;;;;;0BAoDpB,aAA2B;;;UAAd,gEAAU,kBAAI;;AAC/B,eAAI,KAAJ,mCAA0C,KAAK,IAAL,iBAA1C,EAAmE,WAAnE,EAAgF,OAAhF,EAD+B;;AAG/B,gBAAU,sBAAO;AACf,oBAAY,IAAZ;AACA,iBAAS,SAAT;AACA,uBAAe,IAAf;AACA,oCAAU,EAJK;OAAP,EAKP,OALO,CAAV,CAH+B;;AAU/B,UAAI,EAAE,gDAAF,EAAuC;AACzC,eAAO,mBAAQ,MAAR,CAAe,wBAAgB,0BACpC,yDADoC,CAA/B,CAAP,CADyC;OAA3C;;AAKA,UAAM,UAAU,4BAAmB;AACjC,gBAAQ,kBAAW,GAAX;AACR,kBAAU,gBAAS,OAAT;AACV,aAAK,cAAI,MAAJ,CAAW;AACd,oBAAU,KAAK,MAAL,CAAY,QAAZ;AACV,gBAAM,KAAK,MAAL,CAAY,IAAZ;AACN,oBAAa,KAAK,SAAL,YAAb;SAHG,CAAL;AAKA,oBAAY,QAAQ,UAAR;AACZ,cAAM,YAAY,MAAZ,EAAN;AACA,iBAAS,QAAQ,OAAR;OAVK,CAAV,CAfyB;;AA4B/B,UAAM,UAAU,QAAQ,OAAR,GAAkB,IAAlB,CAAuB;eAAY,SAAS,IAAT;OAAZ,CAAjC,CA5ByB;;AA8B/B,cAAQ,IAAR,CAAa,oBAAY;AACvB,iBAAI,IAAJ,kCAAwC,OAAK,IAAL,iBAAxC,EAAiE,QAAjE,EADuB;OAAZ,CAAb,CAEG,KAFH,CAES,eAAO;AACd,iBAAI,KAAJ,0CAAiD,OAAK,IAAL,iBAAjD,EAA0E,GAA1E,EADc;OAAP,CAFT,CA9B+B;;AAoC/B,aAAO,OAAP,CApC+B;;;;;;;;;;;;;;;;;;;0BAoD3B,OAAqB;;;UAAd,gEAAU,kBAAI;;AACzB,eAAI,KAAJ,6CAAoD,KAAK,IAAL,iBAApD,EAA6E,KAA7E,EADyB;;AAGzB,gBAAU,sBAAO;AACf,oBAAY,IAAZ;AACA,iBAAS,SAAT;AACA,uBAAe,IAAf;AACA,oCAAU,EAJK;OAAP,EAKP,OALO,CAAV,CAHyB;;AAUzB,UAAI,SAAS,EAAE,8BAAF,EAA2B;AACtC,eAAO,mBAAQ,MAAR,CAAe,wBAAgB,kEAAhB,CAAf,CAAP,CADsC;OAAxC;;AAIA,UAAM,UAAU,4BAAmB;AACjC,gBAAQ,kBAAW,GAAX;AACR,kBAAU,gBAAS,OAAT;AACV,aAAK,cAAI,MAAJ,CAAW;AACd,oBAAU,KAAK,MAAL,CAAY,QAAZ;AACV,gBAAM,KAAK,MAAL,CAAY,IAAZ;AACN,oBAAa,KAAK,SAAL,YAAb;SAHG,CAAL;AAKA,oBAAY,QAAQ,UAAR;AACZ,eAAO,KAAP;AACA,iBAAS,QAAQ,OAAR;OAVK,CAAV,CAdmB;;AA2BzB,UAAM,UAAU,QAAQ,OAAR,GAAkB,IAAlB,CAAuB;eAAY,SAAS,IAAT;OAAZ,CAAjC,CA3BmB;;AA6BzB,cAAQ,IAAR,CAAa,oBAAY;AACvB,iBAAI,IAAJ,4CAAkD,OAAK,IAAL,iBAAlD,EAA2E,QAA3E,EADuB;OAAZ,CAAb,CAEG,KAFH,CAES,eAAO;AACd,iBAAI,KAAJ,oDAA2D,OAAK,IAAL,iBAA3D,EAAoF,GAApF,EADc;OAAP,CAFT,CA7ByB;;AAmCzB,aAAO,OAAP,CAnCyB;;;;;;;;;;;;;;;;;6BAiDlB,IAAkB;;;UAAd,gEAAU,kBAAI;;AACzB,UAAI,CAAC,EAAD,EAAK;AACP,iBAAI,IAAJ,CAAS,2CAAT,EAAsD,EAAtD,EADO;AAEP,eAAO,mBAAQ,OAAR,CAAgB,IAAhB,CAAP,CAFO;OAAT;;AAKA,eAAI,KAAJ,mCAA0C,KAAK,IAAL,8BAAkC,QAA5E,EANyB;;AAQzB,gBAAU,sBAAO;AACf,oBAAY,IAAZ;AACA,iBAAS,SAAT;AACA,oCAAU,EAHK;OAAP,EAIP,OAJO,CAAV,CARyB;;AAczB,UAAM,UAAU,4BAAmB;AACjC,gBAAQ,kBAAW,GAAX;AACR,kBAAU,gBAAS,OAAT;AACV,aAAK,cAAI,MAAJ,CAAW;AACd,oBAAU,KAAK,MAAL,CAAY,QAAZ;AACV,gBAAM,KAAK,MAAL,CAAY,IAAZ;AACN,oBAAa,KAAK,SAAL,SAAkB,EAA/B;SAHG,CAAL;AAKA,oBAAY,QAAQ,UAAR;AACZ,iBAAS,QAAQ,OAAR;OATK,CAAV,CAdmB;;AA0BzB,UAAM,UAAU,QAAQ,OAAR,GAAkB,IAAlB,CAAuB;eAAY,SAAS,IAAT;OAAZ,CAAjC,CA1BmB;;AA4BzB,cAAQ,IAAR,CAAa,oBAAY;AACvB,iBAAI,IAAJ,kCAAwC,OAAK,IAAL,8BAAkC,QAA1E,EAAiF,QAAjF,EADuB;OAAZ,CAAb,CAEG,KAFH,CAES,eAAO;AACd,iBAAI,KAAJ,2CAAkD,OAAK,IAAL,8BAAkC,QAApF,EAA2F,GAA3F,EADc;OAAP,CAFT,CA5ByB;;AAkCzB,aAAO,OAAP,CAlCyB;;;;;;;;;;;;;;;;;yBAgDtB,QAAsB;;;UAAd,gEAAU,kBAAI;;AACzB,UAAI,CAAC,MAAD,EAAS;AACX,iBAAI,IAAJ,CAAS,qCAAT,EAAgD,MAAhD,EADW;AAEX,eAAO,mBAAQ,OAAR,CAAgB,IAAhB,CAAP,CAFW;OAAb;;AAKA,eAAI,KAAJ,kCAAyC,KAAK,IAAL,iBAAzC,EAAkE,MAAlE,EANyB;;AAQzB,gBAAU,sBAAO;AACf,oBAAY,IAAZ;AACA,iBAAS,SAAT;AACA,oCAAU,EAHK;OAAP,EAIP,OAJO,CAAV,CARyB;;AAczB,UAAM,UAAU,4BAAmB;AACjC,gBAAQ,kBAAW,IAAX;AACR,kBAAU,gBAAS,OAAT;AACV,aAAK,cAAI,MAAJ,CAAW;AACd,oBAAU,KAAK,MAAL,CAAY,QAAZ;AACV,gBAAM,KAAK,MAAL,CAAY,IAAZ;AACN,oBAAU,KAAK,SAAL;SAHP,CAAL;AAKA,oBAAY,QAAQ,UAAR;AACZ,cAAM,MAAN;AACA,iBAAS,QAAQ,OAAR;AACT,gBAAQ,KAAK,MAAL;OAXM,CAAV,CAdmB;;AA4BzB,UAAI,OAAO,WAAP,CAAJ,EAAyB;AACvB,gBAAQ,MAAR,GAAiB,kBAAW,GAAX,CADM;AAEvB,gBAAQ,GAAR,GAAc,cAAI,MAAJ,CAAW;AACvB,oBAAU,KAAK,MAAL,CAAY,QAAZ;AACV,gBAAM,KAAK,MAAL,CAAY,IAAZ;AACN,oBAAa,KAAK,SAAL,SAAkB,OAAO,WAAP,CAA/B;SAHY,CAAd,CAFuB;OAAzB;;AASA,UAAM,UAAU,QAAQ,OAAR,GAAkB,IAAlB,CAAuB;eAAY,SAAS,IAAT;OAAZ,CAAjC,CArCmB;;AAuCzB,cAAQ,IAAR,CAAa,oBAAY;AACvB,iBAAI,IAAJ,iCAAuC,OAAK,IAAL,iBAAvC,EAAgE,QAAhE,EADuB;OAAZ,CAAb,CAEG,KAFH,CAES,eAAO;AACd,iBAAI,KAAJ,0CAAiD,OAAK,IAAL,iBAAjD,EAA0E,GAA1E,EADc;OAAP,CAFT,CAvCyB;;AA6CzB,aAAO,OAAP,CA7CyB;;;;;;;;;;;;;;;;;;;2BA6DpB,OAAqB;;;UAAd,gEAAU,kBAAI;;AAC1B,eAAI,KAAJ,mCAA0C,KAAK,IAAL,iBAA1C,EAAmE,KAAnE,EAD0B;;AAG1B,gBAAU,sBAAO;AACf,oBAAY,IAAZ;AACA,iBAAS,SAAT;AACA,oCAAU,EAHK;OAAP,EAIP,OAJO,CAAV,CAH0B;;AAS1B,UAAI,SAAS,EAAE,8BAAF,EAA2B;AACtC,eAAO,mBAAQ,MAAR,CAAe,wBAAgB,kEAAhB,CAAf,CAAP,CADsC;OAAxC;;AAIA,UAAM,UAAU,4BAAmB;AACjC,gBAAQ,kBAAW,GAAX;AACR,kBAAU,gBAAS,OAAT;AACV,aAAK,cAAI,MAAJ,CAAW;AACd,oBAAU,KAAK,MAAL,CAAY,QAAZ;AACV,gBAAM,KAAK,MAAL,CAAY,IAAZ;AACN,oBAAU,KAAK,SAAL;SAHP,CAAL;AAKA,oBAAY,QAAQ,UAAR;AACZ,eAAO,KAAP;AACA,iBAAS,QAAQ,OAAR;OAVK,CAAV,CAboB;;AA0B1B,UAAM,UAAU,QAAQ,OAAR,GAAkB,IAAlB,CAAuB;eAAY,SAAS,IAAT;OAAZ,CAAjC,CA1BoB;;AA4B1B,cAAQ,IAAR,CAAa,oBAAY;AACvB,iBAAI,IAAJ,kCAAwC,OAAK,IAAL,iBAAxC,EAAiE,QAAjE,EADuB;OAAZ,CAAb,CAEG,KAFH,CAES,eAAO;AACd,iBAAI,KAAJ,2CAAkD,OAAK,IAAL,iBAAlD,EAA2E,GAA3E,EADc;OAAP,CAFT,CA5B0B;;AAkC1B,aAAO,OAAP,CAlC0B;;;;;;;;;;;;;;;;;+BAgDjB,IAAkB;;;UAAd,gEAAU,kBAAI;;AAC3B,UAAI,CAAC,EAAD,EAAK;AACP,iBAAI,IAAJ,CAAS,mCAAT,EAA8C,EAA9C,EADO;AAEP,eAAO,mBAAQ,OAAR,CAAgB,IAAhB,CAAP,CAFO;OAAT;;AAKA,eAAI,KAAJ,gCAAuC,KAAK,IAAL,8BAAkC,QAAzE,EAN2B;;AAQ3B,gBAAU,sBAAO;AACf,oBAAY,IAAZ;AACA,iBAAS,SAAT;AACA,oCAAU,EAHK;OAAP,EAIP,OAJO,CAAV,CAR2B;;AAc3B,UAAM,UAAU,4BAAmB;AACjC,gBAAQ,kBAAW,GAAX;AACR,kBAAU,gBAAS,OAAT;AACV,aAAK,cAAI,MAAJ,CAAW;AACd,oBAAU,KAAK,MAAL,CAAY,QAAZ;AACV,gBAAM,KAAK,MAAL,CAAY,IAAZ;AACN,oBAAa,KAAK,SAAL,SAAkB,EAA/B;SAHG,CAAL;AAKA,oBAAY,QAAQ,UAAR;AACZ,iBAAS,QAAQ,OAAR;OATK,CAAV,CAdqB;;AA0B3B,UAAM,UAAU,QAAQ,OAAR,GAAkB,IAAlB,CAAuB;eAAY,SAAS,IAAT;OAAZ,CAAjC,CA1BqB;;AA4B3B,cAAQ,IAAR,CAAa,oBAAY;AACvB,iBAAI,IAAJ,gCAAsC,OAAK,IAAL,8BAAkC,QAAxE,EAA+E,QAA/E,EADuB;OAAZ,CAAb,CAEG,KAFH,CAES,eAAO;AACd,iBAAI,KAAJ,yCAAgD,OAAK,IAAL,8BAAkC,QAAlF,EAAyF,GAAzF,EADc;OAAP,CAFT,CA5B2B;;AAkC3B,aAAO,OAAP,CAlC2B;;;;wBA/Ub;AACd,UAAI,iBAAe,yBAAoB,KAAK,MAAL,CAAY,MAAZ,CADzB;;AAGd,UAAI,KAAK,IAAL,EAAW;AACb,mBAAc,iBAAY,KAAK,IAAL,CADb;OAAf;;AAIA,aAAO,QAAP,CAPc;;;;SA9BL","file":"stores/networkStore.js","sourcesContent":["import Promise from 'babybird';\nimport { Aggregation } from '../aggregation';\nimport { AuthType, HttpMethod } from '../enums';\nimport { KinveyError } from '../errors';\nimport { Client } from '../client';\nimport { NetworkRequest } from '../requests/network';\nimport { Query } from '../query';\nimport { Log } from '../Log';\nimport qs from 'qs';\nimport url from 'url';\nimport assign from 'lodash/assign';\nimport isString from 'lodash/isString';\nconst appdataNamespace = process.env.KINVEY_DATASTORE_NAMESPACE || 'appdata';\nconst idAttribute = process.env.KINVEY_ID_ATTRIBUTE || '_id';\n\n/**\n * The NetworkStore class is used to find, save, update, remove, count and group enitities\n * in a collection on the network.\n */\nexport class NetworkStore {\n  /**\n   * Creates a new instance of the NetworkStore class.\n   *\n   * @param   {string}  name   Name of the collection\n   *\n   * @throws  {KinveyError}   If the name provided is not a string.\n   */\n  constructor(name) {\n    if (name && !isString(name)) {\n      throw new KinveyError('Name must be a string.');\n    }\n\n    /**\n     * @type {string}\n     */\n    this.name = name;\n\n    /**\n     * @private\n     * @type {Client}\n     */\n    this.client = Client.sharedInstance();\n  }\n\n  /**\n   * The pathname for the store.\n   *\n   * @return  {string}                Pathname\n   */\n  get _pathname() {\n    let pathname = `/${appdataNamespace}/${this.client.appKey}`;\n\n    if (this.name) {\n      pathname = `${pathname}/${this.name}`;\n    }\n\n    return pathname;\n  }\n\n  /**\n   * Finds all entities in a collection. A query can be optionally provided to return\n   * a subset of all entities in a collection or omitted to return all entities in\n   * a collection. The number of entities returned will adhere to the limits specified\n   * at http://devcenter.kinvey.com/rest/guides/datastore#queryrestrictions. A\n   * promise will be returned that will be resolved with the entities or rejected with\n   * an error.\n   *\n   * @param   {Query}                 [query]                                   Query used to filter result.\n   * @param   {Object}                [options]                                 Options\n   * @param   {Properties}            [options.properties]                      Custom properties to send with\n   *                                                                            the request.\n   * @param   {Number}                [options.timeout]                         Timeout for the request.\n   * @return  {Promise}                                                         Promise\n   */\n  find(query, options = {}) {\n    Log.debug(`Retrieving the entities in the ${this.name} collection.`, query);\n\n    options = assign({\n      properties: null,\n      timeout: undefined,\n      handler() {}\n    }, options);\n    options.flags = qs.parse(options.flags);\n\n    if (query && !(query instanceof Query)) {\n      return Promise.reject(new KinveyError('Invalid query. It must be an instance of the Kinvey.Query class.'));\n    }\n\n    const request = new NetworkRequest({\n      method: HttpMethod.GET,\n      authType: AuthType.Default,\n      url: url.format({\n        protocol: this.client.protocol,\n        host: this.client.host,\n        pathname: this._pathname\n      }),\n      properties: options.properties,\n      query: query,\n      timeout: options.timeout,\n      client: this.client\n    });\n\n    const promise = request.execute().then(response => response.data);\n\n    promise.then(response => {\n      Log.info(`Retrieved the entities in the ${this.name} collection.`, response);\n    }).catch(error => {\n      Log.error(`Failed to retrieve the entities in the ${this.name} collection.`, error);\n    });\n\n    return promise;\n  }\n\n  /**\n   * Groups entities in a collection. An aggregation can be optionally provided to group\n   * a subset of entities in a collection or omitted to group all the entities\n   * in a collection. A promise will be returned that will be resolved with the result\n   * or rejected with an error.\n   *\n   * @param   {Aggregation}           aggregation                               Aggregation used to group entities.\n   * @param   {Object}                [options]                                 Options\n   * @param   {Properties}            [options.properties]                      Custom properties to send with\n   *                                                                            the request.\n   * @param   {Number}                [options.timeout]                         Timeout for the request.\n   * @return  {Promise}                                                         Promise\n   */\n  group(aggregation, options = {}) {\n    Log.debug(`Grouping the entities in the ${this.name} collection.`, aggregation, options);\n\n    options = assign({\n      properties: null,\n      timeout: undefined,\n      useDeltaFetch: true,\n      handler() {}\n    }, options);\n\n    if (!(aggregation instanceof Aggregation)) {\n      return Promise.reject(new KinveyError('Invalid aggregation. ' +\n        'It must be an instance of the Kinvey.Aggregation class.'));\n    }\n\n    const request = new NetworkRequest({\n      method: HttpMethod.GET,\n      authType: AuthType.Default,\n      url: url.format({\n        protocol: this.client.protocol,\n        host: this.client.host,\n        pathname: `${this._pathname}/_group`\n      }),\n      properties: options.properties,\n      data: aggregation.toJSON(),\n      timeout: options.timeout\n    });\n\n    const promise = request.execute().then(response => response.data);\n\n    promise.then(response => {\n      Log.info(`Grouped the entities in the ${this.name} collection.`, response);\n    }).catch(err => {\n      Log.error(`Failed to group the entities in the ${this.name} collection.`, err);\n    });\n\n    return promise;\n  }\n\n  /**\n   * Counts entities in a collection. A query can be optionally provided to count\n   * a subset of entities in a collection or omitted to count all the entities\n   * in a collection. A promise will be returned that will be resolved with the count\n   * or rejected with an error.\n   *\n   * @param   {Query}                 [query]                                   Query to count a subset of entities.\n   * @param   {Object}                [options]                                 Options\n   * @param   {Properties}            [options.properties]                      Custom properties to send with\n   *                                                                            the request.\n   * @param   {Number}                [options.timeout]                         Timeout for the request.\n   * @return  {Promise}                                                         Promise\n   */\n  count(query, options = {}) {\n    Log.debug(`Counting the number of entities in the ${this.name} collection.`, query);\n\n    options = assign({\n      properties: null,\n      timeout: undefined,\n      useDeltaFetch: true,\n      handler() {}\n    }, options);\n\n    if (query && !(query instanceof Query)) {\n      return Promise.reject(new KinveyError('Invalid query. It must be an instance of the Kinvey.Query class.'));\n    }\n\n    const request = new NetworkRequest({\n      method: HttpMethod.GET,\n      authType: AuthType.Default,\n      url: url.format({\n        protocol: this.client.protocol,\n        host: this.client.host,\n        pathname: `${this._pathname}/_count`\n      }),\n      properties: options.properties,\n      query: query,\n      timeout: options.timeout\n    });\n\n    const promise = request.execute().then(response => response.data);\n\n    promise.then(response => {\n      Log.info(`Counted the number of entities in the ${this.name} collection.`, response);\n    }).catch(err => {\n      Log.error(`Failed to count the number of entities in the ${this.name} collection.`, err);\n    });\n\n    return promise;\n  }\n\n  /**\n   * Retrieves a single entity in a collection by id. A promise will be returned that will\n   * be resolved with the entity or rejected with an error.\n   *\n   * @param   {string}                id                                        Document Id\n   * @param   {Object}                [options]                                 Options\n   * @param   {Properties}            [options.properties]                      Custom properties to send with\n   *                                                                            the request.\n   * @param   {Number}                [options.timeout]                         Timeout for the request.\n   * @return  {Promise}                                                         Promise\n   */\n  findById(id, options = {}) {\n    if (!id) {\n      Log.warn('No id was provided to retrieve an entity.', id);\n      return Promise.resolve(null);\n    }\n\n    Log.debug(`Retrieving the entity in the ${this.name} collection with id = ${id}.`);\n\n    options = assign({\n      properties: null,\n      timeout: undefined,\n      handler() {}\n    }, options);\n\n    const request = new NetworkRequest({\n      method: HttpMethod.GET,\n      authType: AuthType.Default,\n      url: url.format({\n        protocol: this.client.protocol,\n        host: this.client.host,\n        pathname: `${this._pathname}/${id}`,\n      }),\n      properties: options.properties,\n      timeout: options.timeout\n    });\n\n    const promise = request.execute().then(response => response.data);\n\n    promise.then(response => {\n      Log.info(`Retrieved the entity in the ${this.name} collection with id = ${id}.`, response);\n    }).catch(err => {\n      Log.error(`Failed to retrieve the entity in the ${this.name} collection with id = ${id}.`, err);\n    });\n\n    return promise;\n  }\n\n  /**\n   * Save a entity or an array of entities to a collection. A promise will be returned that\n   * will be resolved with the saved entity/entities or rejected with an error.\n   *\n   * @param   {Object|Array}          doc                                       Document or entities to save.\n   * @param   {Object}                options                                   Options\n   * @param   {Properties}            [options.properties]                      Custom properties to send with\n   *                                                                            the request.\n   * @param   {Number}                [options.timeout]                         Timeout for the request.\n   * @return  {Promise}                                                         Promise\n   */\n  save(entity, options = {}) {\n    if (!entity) {\n      Log.warn('No entity was provided to be saved.', entity);\n      return Promise.resolve(null);\n    }\n\n    Log.debug(`Saving the entity(s) to the ${this.name} collection.`, entity);\n\n    options = assign({\n      properties: null,\n      timeout: undefined,\n      handler() {}\n    }, options);\n\n    const request = new NetworkRequest({\n      method: HttpMethod.POST,\n      authType: AuthType.Default,\n      url: url.format({\n        protocol: this.client.protocol,\n        host: this.client.host,\n        pathname: this._pathname\n      }),\n      properties: options.properties,\n      data: entity,\n      timeout: options.timeout,\n      client: this.client\n    });\n\n    if (entity[idAttribute]) {\n      request.method = HttpMethod.PUT;\n      request.url = url.format({\n        protocol: this.client.protocol,\n        host: this.client.host,\n        pathname: `${this._pathname}/${entity[idAttribute]}`\n      });\n    }\n\n    const promise = request.execute().then(response => response.data);\n\n    promise.then(response => {\n      Log.info(`Saved the entity(s) to the ${this.name} collection.`, response);\n    }).catch(err => {\n      Log.error(`Failed to save the entity(s) to the ${this.name} collection.`, err);\n    });\n\n    return promise;\n  }\n\n  /**\n   * Remove entities in a collection. A query can be optionally provided to remove\n   * a subset of entities in a collection or omitted to remove all entities in a\n   * collection. A promise will be returned that will be resolved with a count of the\n   * number of entities removed or rejected with an error.\n   *\n   * @param   {Query}                 [query]                                   Query\n   * @param   {Object}                options                                   Options\n   * @param   {Properties}            [options.properties]                      Custom properties to send with\n   *                                                                            the request.\n   * @param   {Number}                [options.timeout]                         Timeout for the request.\n   * @return  {Promise}                                                         Promise\n   */\n  remove(query, options = {}) {\n    Log.debug(`Removing the entities in the ${this.name} collection.`, query);\n\n    options = assign({\n      properties: null,\n      timeout: undefined,\n      handler() {}\n    }, options);\n\n    if (query && !(query instanceof Query)) {\n      return Promise.reject(new KinveyError('Invalid query. It must be an instance of the Kinvey.Query class.'));\n    }\n\n    const request = new NetworkRequest({\n      method: HttpMethod.GET,\n      authType: AuthType.Default,\n      url: url.format({\n        protocol: this.client.protocol,\n        host: this.client.host,\n        pathname: this._pathname,\n      }),\n      properties: options.properties,\n      query: query,\n      timeout: options.timeout\n    });\n\n    const promise = request.execute().then(response => response.data);\n\n    promise.then(response => {\n      Log.info(`Removed the entities in the ${this.name} collection.`, response);\n    }).catch(err => {\n      Log.error(`Failed to remove the entities in the ${this.name} collection.`, err);\n    });\n\n    return promise;\n  }\n\n  /**\n   * Remove an entity in a collection. A promise will be returned that will be\n   * resolved with a count of the number of entities removed or rejected with an error.\n   *\n   * @param   {string}                id                                        Document Id\n   * @param   {Object}                options                                   Options\n   * @param   {Properties}            [options.properties]                      Custom properties to send with\n   *                                                                            the request.\n   * @param   {Number}                [options.timeout]                         Timeout for the request.\n   * @return  {Promise}                                                         Promise\n   */\n  removeById(id, options = {}) {\n    if (!id) {\n      Log.warn('No id was provided to be removed.', id);\n      return Promise.resolve(null);\n    }\n\n    Log.debug(`Removing an entity in the ${this.name} collection with id = ${id}.`);\n\n    options = assign({\n      properties: null,\n      timeout: undefined,\n      handler() {}\n    }, options);\n\n    const request = new NetworkRequest({\n      method: HttpMethod.GET,\n      authType: AuthType.Default,\n      url: url.format({\n        protocol: this.client.protocol,\n        host: this.client.host,\n        pathname: `${this._pathname}/${id}`,\n      }),\n      properties: options.properties,\n      timeout: options.timeout\n    });\n\n    const promise = request.execute().then(response => response.data);\n\n    promise.then(response => {\n      Log.info(`Removed the entity in the ${this.name} collection with id = ${id}.`, response);\n    }).catch(err => {\n      Log.error(`Failed to remove the entity in the ${this.name} collection with id = ${id}.`, err);\n    });\n\n    return promise;\n  }\n}\n"],"sourceRoot":"/source/"}